@page "/simulador"
@page "/"
@inject IJSRuntime JS
@using Simulador_Assembly_Final.Classes

<h3 class="titulo">Simulador de Assembly</h3>

<div class="form-container">
    <div class="form-group">
        <label for="filePath">Caminho do Arquivo</label>
        <input id="filePath" @bind="simuladorObj.FilePath" placeholder="Ex: C:\código\teste.asm" />
    </div>

    <div class="form-group">
        <label for="clockMHz">Clock (MHz)</label>
        <input id="clockMHz" type="number" @bind="simuladorObj.ClockMHz" />
    </div>

    <div class="form-group">
        <label for="ciclosR">Ciclos para instruções tipo R</label>
        <input id="ciclosR" type="number" @bind="simuladorObj.CyclesR" />
    </div>

    <div class="form-group">
        <label for="ciclosI">Ciclos para instruções tipo I</label>
        <input id="ciclosI" type="number" @bind="simuladorObj.CyclesI" />
    </div>

    <div class="form-group">
        <label for="ciclosJ">Ciclos para instruções tipo J</label>
        <input id="ciclosJ" type="number" @bind="simuladorObj.CyclesJ" />
    </div>

    <button class="btn-primary" @onclick="ExecutarSimulacaoAsync">Executar Simulação</button>

    @if (!string.IsNullOrWhiteSpace(resultadoSimulacao))
    {
        <div class="resultado">
            <pre>@resultadoSimulacao</pre>
        </div>
    }
</div>

@if (mostrarModal)
{
    <div style="position:fixed; inset:0; background-color:rgba(0,0,0,0.5); display:flex; justify-content:center; align-items:center; z-index:1000;">

        <div class="modal-container" style="background:#fff; padding:2rem; border-radius:10px; min-width:300px; box-shadow:0 0 10px #000;">

            <h4>Execução Clock a Clock</h4>

            <div class="painel-execucao">
                <div class="bloco">
                    <strong>Registradores</strong>
                    @foreach (var reg in simuladorObj.Registradores)
                    {
                        <div>@reg.Key: @reg.Value</div>
                    }
                </div>

                <div class="bloco">
                    <strong>Memória de Dados</strong>
                    @foreach (var item in memoria.MostrarEstadoMemoriaDados())
                    {
                        <div>@item</div>
                    }
                </div>
            </div>

            <div class="painel-execucao">
                <div class="bloco bloco-longo">
                    <strong>Memória de Programa</strong>
                    @foreach (var linha in memoriaInstrucao.ObterEstadoMemoriaDados())
                    {
                        <div class="linha-execucao">@linha</div>
                    }
                </div>
            </div>

            <div class="painel-execucao">
                <div class="bloco">
                    <strong>Linha em execução</strong>
                    <div>
                        @memoriaInstrucao.ObterInstrucaoHexadecimal(LinhaAtualCompletaAssembly, (linhaAtual - 1) * 4)
                    </div>
                </div>

                <div class="bloco">
                    <strong>Linha em execução (Assembly)</strong>
                    <div>
                        @LinhaAtualCompletaAssembly
                    </div>
                </div>
            </div>

            <div class="modal-buttons">
                @if (TemMaisInstrucoes && !ExecutandoDelay)
                {
                    <button class="btn-primary" @onclick="ExecutarClock">Clock++</button>
                }
                else if (TemMaisInstrucoes && ExecutandoDelay)
                {
                }
                else
                {
                    <div class="bloco" style="display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center;">
                        <strong>Resultados Finais</strong>
                        <div>
                            Total de Instruções Executadas: @Totalizador.TotalInstrucoes<br />
                            Total de Ciclos: @Totalizador.TotalCiclos<br />
                            Tempo Total Estimado de Execução: @Totalizador.TempoTotalSegundos segundos
                        </div>
                    </div>
                }

                <button class="btn-secondary" @onclick="FecharModal">Fechar</button>
            </div>
        </div>
    </div>

}


@code {
    private Simulador simuladorObj { get; set; } = new();
    private MemoriaInstrucao memoriaInstrucao { get; set; } = new();
    private Memoria memoria { get; set; } = new();
    private Instrucoes instrucoes { get; set; } = new();
    private TabelaInstrucoes tabelaInstrucoes { get; set; } = new();
    private Dictionary<string, int> Labels = new();
    private Dictionary<string, int> Registradores = new();
    private List<string> MemoriaPrograma = new();
    private List<string> LinhasPrograma { get; set; } = new();

    private int linhaAtual = 0;
    private bool mostrarModal = false;
    private bool TemMaisInstrucoes => linhaAtual < LinhasPrograma.Count - 1;
    private bool ExecutandoDelay = false;
    private string LinhaAtualCompletaAssembly { get; set; }
    private string resultadoSimulacao = string.Empty;

    private int ContadorIntrucoes = 0;
    private int qtdCiclosAnteriores = 0;

    private async Task ExecutarSimulacaoAsync()
    {
        if (string.IsNullOrWhiteSpace(simuladorObj.FilePath) || !File.Exists(simuladorObj.FilePath))
        {
            resultadoSimulacao = "Arquivo não encontrado.";
            return;
        }

        if (simuladorObj.ClockMHz <= 0 || simuladorObj.CyclesR <= 0 || simuladorObj.CyclesI <= 0 || simuladorObj.CyclesJ <= 0)
        {
            resultadoSimulacao = "Verifique os valores de clock e ciclos. Todos devem ser maiores que zero.";
            return;
        }

        simuladorObj.TempoClockUnicoSegundos = await simuladorObj.ObterTempoMs(simuladorObj.ClockMHz);

        resultadoSimulacao = $"--- Parâmetros Iniciais ---\n" +
        $"Arquivo: {simuladorObj.FilePath}\n" +
        $"Clock: {simuladorObj.ClockMHz} MHz\n" +
        $"Tempo de um ciclo de clock: {simuladorObj.TempoClockUnicoSegundos} segundos\n" +
        $"Ciclos tipo R: {simuladorObj.CyclesR} | Ciclos tipo I: {simuladorObj.CyclesI} | Ciclos tipo J: {simuladorObj.CyclesJ}\n\n";

        Registradores = TabelaInstrucoes.Registradores.CriarRegistradores();
        LinhasPrograma = File.ReadAllLines(simuladorObj.FilePath).ToList();

        // Salvar em variáveis de estado para uso no ExecutarClock()
        MemoriaPrograma = LinhasPrograma.Where(l => !string.IsNullOrWhiteSpace(l) && !l.Trim().StartsWith("#")).ToList();

        // Mapear labels
        Labels.Clear();
        for (int i = 0; i < LinhasPrograma.Count; i++)
        {
            var linha = LinhasPrograma[i].Trim();

            if (linha.EndsWith(":"))
            {
                string nomeLabel = linha.Substring(0, linha.Length - 1).Trim();
                Labels[nomeLabel] = i;
            }
        }

        // Parse das instruções
        instrucoes = new Instrucoes();
        linhaAtual = 0;
        mostrarModal = true;
        StateHasChanged();
    }

    private void FecharModal()
    {
        mostrarModal = false;
        linhaAtual = 0;
        resultadoSimulacao = string.Empty;
        simuladorObj = new(); // Cria um novo objeto, limpando os campos do formulário
        memoriaInstrucao = new();
        memoria = new();
        instrucoes = new();
        tabelaInstrucoes = new();
        Labels = new();
        Registradores = new();
        LinhasPrograma = new();
        MemoriaPrograma = new();
        LinhaAtualCompletaAssembly = string.Empty;
        ContadorIntrucoes = 0;
        Totalizador.Reset(); // Supondo que exista um método estático para resetar os totais

        StateHasChanged(); // Garante que a interface seja atualizada
    }


    private async Task ExecutarClock()
    {
        if (ContadorIntrucoes == 0)
        {
        }
        else if (ContadorIntrucoes > 0)
        {
            ExecutandoDelay = true;
            await simuladorObj.AguardarTempo(simuladorObj.TempoClockUnicoSegundos);
            ExecutandoDelay = false;
            ContadorIntrucoes = qtdCiclosAnteriores - ContadorIntrucoes;
            StateHasChanged();
            return;
        }

        while (linhaAtual < LinhasPrograma.Count)
        {
            ExecutandoDelay = true;
            StateHasChanged();
            LinhaAtualCompletaAssembly = string.Empty;
            var linha = LinhasPrograma[linhaAtual].Trim();
            LinhaAtualCompletaAssembly = linha;
            if (string.IsNullOrWhiteSpace(linha) || linha.StartsWith("#") || linha.EndsWith(":"))
            {
                linhaAtual++;
                continue;
            }

            ContadorIntrucoes++;
            var (instrucao, operandos) = Instrucoes.ParseInstrucao(linha);

            if (!string.IsNullOrEmpty(instrucao) && operandos != null)
            {
                Totalizador.TotalInstrucoes++;

                if (instrucoes == null)
                    instrucoes = new Instrucoes();

                var ciclosInstrucoes = Instrucoes.ParseWordsToArray(
                simuladorObj.FilePath,
                simuladorObj.CyclesI,
                simuladorObj.CyclesJ,
                simuladorObj.CyclesR,
                simuladorObj.TempoClockUnicoSegundos,
                memoriaInstrucao
                );

                if (ciclosInstrucoes.TryGetValue(instrucao, out int ciclosInstrucao))
                    Totalizador.TotalCiclos += ciclosInstrucao;

                instrucoes.Executar(instrucao, operandos, simuladorObj.Registradores, memoria, Labels, linhaAtual, ciclosInstrucoes, simuladorObj.TempoClockUnicoSegundos, memoriaInstrucao);

                if (instrucao.StartsWith("j"))
                {
                    string label = operandos.FirstOrDefault();
                    if (Labels.ContainsKey(label))
                        linhaAtual = Labels[label];
                    else
                        resultadoSimulacao = $"Erro: Label {label} não encontrada.";
                }
                else if (instrucao.StartsWith("b"))
                {
                    linhaAtual = simuladorObj.Registradores["PC"];
                }
                else
                {
                    linhaAtual++;
                }

                if (TabelaInstrucoes.Instrucoes.TryGetValue(instrucao, out var dicInstrucoes))
                {
                    int ciclos = dicInstrucoes.Item2;
                    await simuladorObj.AguardarTempo(simuladorObj.TempoClockUnicoSegundos);
                    qtdCiclosAnteriores = ciclos;
                }
                ExecutandoDelay = false;
                StateHasChanged();
                ContadorIntrucoes = qtdCiclosAnteriores - ContadorIntrucoes;
                qtdCiclosAnteriores--;
                break; // Executou uma instrução, sai do loop
            }
            else
            {
                resultadoSimulacao = $"Erro ao processar a linha: {linha}. A instrução não foi válida.";
                mostrarModal = false;
                break;
            }
        }

        StateHasChanged();
    }
}
<style>
    /* Container do formulário */
    .form-container {
        max-width: 600px;
        margin: 2rem auto;
        padding: 1.5rem;
        background: #f9f9f9;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .form-group {
        margin-bottom: 1.2rem;
    }

        .form-group label {
            display: block;
            margin-bottom: 0.3rem;
            font-weight: 600;
            color: #333;
        }

        .form-group input {
            width: 100%;
            padding: 0.5rem 0.7rem;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
            box-sizing: border-box;
        }

    button {
        cursor: pointer;
        font-weight: 600;
        border: none;
        border-radius: 6px;
        padding: 0.6rem 1.3rem;
        transition: background-color 0.3s ease;
    }

    .btn-primary {
        background-color: #007bff;
        color: white;
    }

        .btn-primary:hover {
            background-color: #0056b3;
        }

    .btn-secondary {
        background-color: #6c757d;
        color: white;
        margin-left: 0.5rem;
    }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

    .resultado {
        margin-top: 1.5rem;
        background-color: #eef2f7;
        padding: 1rem;
        border-radius: 6px;
        white-space: pre-wrap;
        font-family: Consolas, monospace;
        max-height: 300px;
        overflow-y: auto;
    }

    /* Painel de execução geral */
    .painel-execucao {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-bottom: 1.5rem;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    /* Blocos lado a lado */
    .bloco {
        flex: 1 1 45%;
        background: #f7f9fc;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
        max-height: calc(30vh); /* ajusta para caber na tela */
        overflow-y: auto;
    }

    /* Bloco que ocupa linha inteira */
    .bloco-longo {
        flex: 1 1 100%;
        background: #f7f9fc;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: inset 0 0 5px rgba(0,0,0,0.05);
        max-height: calc(30vh);
        overflow-y: auto;
    }

    /* Linha atual destacada */
    .linha-execucao {
        padding: 3px 5px;
        border-radius: 4px;
        margin-bottom: 2px;
        font-family: Consolas, monospace;
        font-size: 0.9rem;
        color: #444;
    }

    .linha-atual {
        background-color: #d1e7dd;
        border-left: 4px solid #198754;
        font-weight: 600;
        color: #0f5132;
    }

    /* Modal adaptável à altura da tela */
    .modal-container {
        max-height: 95vh;
        overflow-y: auto;
    }

    .modal-buttons {
        text-align: right;
    }
</style>

